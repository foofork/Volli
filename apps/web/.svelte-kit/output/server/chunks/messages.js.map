{"version":3,"file":"messages.js","sources":["../../../../src/lib/stores/vault.ts","../../../../src/lib/stores/messages.ts"],"sourcesContent":["import { writable, get } from 'svelte/store';\nimport { auth } from './auth';\n\n// Local type definitions\ninterface QueryOptions {\n\ttype?: string;\n\tconversationId?: string;\n\t[key: string]: any;\n}\n\ninterface VaultState {\n\tisInitialized: boolean;\n\tisUnlocked: boolean;\n\tisLoading: boolean;\n\terror: string | null;\n\tcollections: string[];\n}\n\nfunction createVaultStore() {\n\tconst { subscribe, set, update } = writable<VaultState>({\n\t\tisInitialized: false,\n\t\tisUnlocked: false,\n\t\tisLoading: false,\n\t\terror: null,\n\t\tcollections: []\n\t});\n\n\tlet vaultKey: Uint8Array | null = null;\n\n\tasync function initialize() {\n\t\tupdate(state => ({ ...state, isLoading: true, error: null }));\n\t\t\n\t\ttry {\n\t\t\tconst authState = get(auth);\n\t\t\tif (!authState.isAuthenticated) {\n\t\t\t\tthrow new Error('Not authenticated');\n\t\t\t}\n\n\t\t\t// Check if vault key exists in session storage\n\t\t\tconst storedKey = sessionStorage.getItem('volli_vault_key');\n\t\t\tif (storedKey) {\n\t\t\t\tvaultKey = new Uint8Array(Buffer.from(storedKey, 'base64'));\n\t\t\t\tupdate(state => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisInitialized: true,\n\t\t\t\t\tisUnlocked: true,\n\t\t\t\t\tisLoading: false,\n\t\t\t\t\tcollections: ['messages', 'contacts', 'files']\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tupdate(state => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisInitialized: true,\n\t\t\t\t\tisUnlocked: false,\n\t\t\t\t\tisLoading: false\n\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to initialize vault'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function unlock(passphrase: string) {\n\t\tupdate(state => ({ ...state, isLoading: true, error: null }));\n\t\t\n\t\ttry {\n\t\t\t// Derive key from passphrase (simplified for now)\n\t\t\tconst encoder = new TextEncoder();\n\t\t\tconst data = encoder.encode(passphrase);\n\t\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\t\t\tvaultKey = new Uint8Array(hashBuffer);\n\t\t\t\n\t\t\t// Store in session storage\n\t\t\tsessionStorage.setItem('volli_vault_key', Buffer.from(vaultKey).toString('base64'));\n\t\t\t\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisUnlocked: true,\n\t\t\t\tisLoading: false,\n\t\t\t\tcollections: ['messages', 'contacts', 'files']\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to unlock vault'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function lock() {\n\t\tvaultKey = null;\n\t\tsessionStorage.removeItem('volli_vault_key');\n\t\t\n\t\tupdate(state => ({\n\t\t\t...state,\n\t\t\tisUnlocked: false,\n\t\t\tcollections: []\n\t\t}));\n\t}\n\n\tasync function store(collection: string, data: any) {\n\t\tif (!vaultKey) throw new Error('Vault is locked');\n\t\t\n\t\t// Store encrypted data in IndexedDB (simplified)\n\t\tconst db = await openDB();\n\t\tconst tx = db.transaction(collection, 'readwrite');\n\t\tawait tx.objectStore(collection).put({\n\t\t\tid: data.id || crypto.randomUUID(),\n\t\t\tdata: JSON.stringify(data),\n\t\t\ttimestamp: Date.now()\n\t\t});\n\t}\n\n\tasync function query(collection: string, options?: QueryOptions) {\n\t\tif (!vaultKey) throw new Error('Vault is locked');\n\t\t\n\t\t// Query from IndexedDB (simplified)\n\t\tconst db = await openDB();\n\t\tconst tx = db.transaction(collection, 'readonly');\n\t\tconst items = await tx.objectStore(collection).getAll();\n\t\t\n\t\treturn items.map(item => JSON.parse(item.data));\n\t}\n\n\tasync function openDB(): Promise<IDBDatabase> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open('volli_vault', 1);\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t\trequest.onsuccess = () => resolve(request.result);\n\t\t\t\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = (event.target as IDBOpenDBRequest).result;\n\t\t\t\t['messages', 'contacts', 'files'].forEach(collection => {\n\t\t\t\t\tif (!db.objectStoreNames.contains(collection)) {\n\t\t\t\t\t\tdb.createObjectStore(collection, { keyPath: 'id' });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t}\n\n\treturn {\n\t\tsubscribe,\n\t\tinitialize,\n\t\tunlock,\n\t\tlock,\n\t\tstore,\n\t\tquery\n\t};\n}\n\nexport const vault = createVaultStore();","import { writable, derived } from 'svelte/store';\nimport { vault } from './vault';\n\n// Local type definitions\ninterface MessageContent {\n\ttype: 'text' | 'file' | 'image';\n\ttext?: string;\n\tfileId?: string;\n\tmetadata?: Record<string, any>;\n}\n\ninterface Message {\n\tid: string;\n\tconversationId: string;\n\tsenderId: string;\n\tcontent: MessageContent;\n\ttimestamp: Date;\n\tstatus: 'sending' | 'sent' | 'delivered' | 'read' | 'failed';\n\tversion: number;\n}\n\ninterface Conversation {\n\tid: string;\n\ttype: 'direct' | 'group';\n\tparticipants: string[];\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n\tlastMessage?: Message;\n\tmetadata: {\n\t\tname: string;\n\t\tavatar: string;\n\t\tdescription: string;\n\t};\n}\n\ninterface MessagesState {\n\tconversations: Map<string, Conversation>;\n\tmessages: Map<string, Message[]>;\n\tactiveConversationId: string | null;\n\tisLoading: boolean;\n\terror: string | null;\n}\n\nfunction createMessagesStore() {\n\tconst { subscribe, set, update } = writable<MessagesState>({\n\t\tconversations: new Map(),\n\t\tmessages: new Map(),\n\t\tactiveConversationId: null,\n\t\tisLoading: false,\n\t\terror: null\n\t});\n\n\tasync function loadConversations() {\n\t\tupdate(state => ({ ...state, isLoading: true, error: null }));\n\t\t\n\t\ttry {\n\t\t\tconst conversations = await vault.query('messages', {\n\t\t\t\ttype: 'conversation'\n\t\t\t});\n\t\t\t\n\t\t\tconst conversationsMap = new Map<string, Conversation>();\n\t\t\tconversations.forEach((conv: Conversation) => {\n\t\t\t\tconversationsMap.set(conv.id, conv);\n\t\t\t});\n\t\t\t\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tconversations: conversationsMap,\n\t\t\t\tisLoading: false\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to load conversations'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function loadMessages(conversationId: string) {\n\t\ttry {\n\t\t\tconst messages = await vault.query('messages', {\n\t\t\t\tconversationId,\n\t\t\t\ttype: 'message'\n\t\t\t});\n\t\t\t\n\t\t\tupdate(state => {\n\t\t\t\tconst newMessages = new Map(state.messages);\n\t\t\t\tnewMessages.set(conversationId, messages);\n\t\t\t\treturn { ...state, messages: newMessages };\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to load messages'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function createConversation(participants: string[], name?: string): Promise<string> {\n\t\tconst conversation: Conversation = {\n\t\t\tid: crypto.randomUUID(),\n\t\t\ttype: participants.length > 2 ? 'group' : 'direct',\n\t\t\tparticipants,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date(),\n\t\t\tmetadata: {\n\t\t\t\tname: name || `Chat with ${participants.join(', ')}`,\n\t\t\t\tavatar: '',\n\t\t\t\tdescription: ''\n\t\t\t}\n\t\t};\n\t\t\n\t\tawait vault.store('messages', { ...conversation, type: 'conversation' });\n\t\t\n\t\tupdate(state => {\n\t\t\tconst newConversations = new Map(state.conversations);\n\t\t\tnewConversations.set(conversation.id, conversation);\n\t\t\treturn { ...state, conversations: newConversations };\n\t\t});\n\t\t\n\t\treturn conversation.id;\n\t}\n\n\tasync function sendMessage(conversationId: string, content: MessageContent) {\n\t\tconst message: Message = {\n\t\t\tid: crypto.randomUUID(),\n\t\t\tconversationId,\n\t\t\tsenderId: 'current-user', // Get from auth store\n\t\t\tcontent,\n\t\t\ttimestamp: new Date(),\n\t\t\tstatus: 'sent',\n\t\t\tversion: 1\n\t\t};\n\t\t\n\t\tawait vault.store('messages', { ...message, type: 'message' });\n\t\t\n\t\tupdate(state => {\n\t\t\tconst newMessages = new Map(state.messages);\n\t\t\tconst conversationMessages = newMessages.get(conversationId) || [];\n\t\t\tnewMessages.set(conversationId, [...conversationMessages, message]);\n\t\t\t\n\t\t\t// Update conversation's last message\n\t\t\tconst newConversations = new Map(state.conversations);\n\t\t\tconst conversation = newConversations.get(conversationId);\n\t\t\tif (conversation) {\n\t\t\t\tconversation.lastMessage = message;\n\t\t\t\tconversation.updatedAt = new Date();\n\t\t\t\tnewConversations.set(conversationId, conversation);\n\t\t\t}\n\t\t\t\n\t\t\treturn { \n\t\t\t\t...state, \n\t\t\t\tmessages: newMessages,\n\t\t\t\tconversations: newConversations\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction setActiveConversation(conversationId: string | null) {\n\t\tupdate(state => ({ ...state, activeConversationId: conversationId }));\n\t\tif (conversationId) {\n\t\t\tloadMessages(conversationId);\n\t\t}\n\t}\n\n\treturn {\n\t\tsubscribe,\n\t\tloadConversations,\n\t\tloadMessages,\n\t\tcreateConversation,\n\t\tsendMessage,\n\t\tsetActiveConversation\n\t};\n}\n\nexport const messages = createMessagesStore();\n\nexport const activeConversation = derived(\n\tmessages,\n\t$messages => $messages.activeConversationId ? \n\t\t$messages.conversations.get($messages.activeConversationId) : null\n);\n\nexport const activeMessages = derived(\n\tmessages,\n\t$messages => $messages.activeConversationId ? \n\t\t$messages.messages.get($messages.activeConversationId) || [] : []\n);"],"names":["get","messages"],"mappings":"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"}