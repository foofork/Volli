{"version":3,"file":"vault.4a87f3ed.js","sources":["../../../../../../src/lib/stores/vault.ts"],"sourcesContent":["import { writable, get } from 'svelte/store';\nimport { auth } from './auth';\n\n// Local type definitions\ninterface QueryOptions {\n\ttype?: string;\n\tconversationId?: string;\n\t[key: string]: any;\n}\n\ninterface VaultState {\n\tisInitialized: boolean;\n\tisUnlocked: boolean;\n\tisLoading: boolean;\n\terror: string | null;\n\tcollections: string[];\n}\n\nfunction createVaultStore() {\n\tconst { subscribe, set, update } = writable<VaultState>({\n\t\tisInitialized: false,\n\t\tisUnlocked: false,\n\t\tisLoading: false,\n\t\terror: null,\n\t\tcollections: []\n\t});\n\n\tlet vaultKey: Uint8Array | null = null;\n\n\tasync function initialize() {\n\t\tupdate(state => ({ ...state, isLoading: true, error: null }));\n\t\t\n\t\ttry {\n\t\t\tconst authState = get(auth);\n\t\t\tif (!authState.isAuthenticated) {\n\t\t\t\tthrow new Error('Not authenticated');\n\t\t\t}\n\n\t\t\t// Check if vault key exists in session storage\n\t\t\tconst storedKey = sessionStorage.getItem('volli_vault_key');\n\t\t\tif (storedKey) {\n\t\t\t\tvaultKey = new Uint8Array(Buffer.from(storedKey, 'base64'));\n\t\t\t\tupdate(state => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisInitialized: true,\n\t\t\t\t\tisUnlocked: true,\n\t\t\t\t\tisLoading: false,\n\t\t\t\t\tcollections: ['messages', 'contacts', 'files']\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tupdate(state => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisInitialized: true,\n\t\t\t\t\tisUnlocked: false,\n\t\t\t\t\tisLoading: false\n\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to initialize vault'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function unlock(passphrase: string) {\n\t\tupdate(state => ({ ...state, isLoading: true, error: null }));\n\t\t\n\t\ttry {\n\t\t\t// Derive key from passphrase (simplified for now)\n\t\t\tconst encoder = new TextEncoder();\n\t\t\tconst data = encoder.encode(passphrase);\n\t\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\t\t\tvaultKey = new Uint8Array(hashBuffer);\n\t\t\t\n\t\t\t// Store in session storage\n\t\t\tsessionStorage.setItem('volli_vault_key', Buffer.from(vaultKey).toString('base64'));\n\t\t\t\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisUnlocked: true,\n\t\t\t\tisLoading: false,\n\t\t\t\tcollections: ['messages', 'contacts', 'files']\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to unlock vault'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function lock() {\n\t\tvaultKey = null;\n\t\tsessionStorage.removeItem('volli_vault_key');\n\t\t\n\t\tupdate(state => ({\n\t\t\t...state,\n\t\t\tisUnlocked: false,\n\t\t\tcollections: []\n\t\t}));\n\t}\n\n\tasync function store(collection: string, data: any) {\n\t\tif (!vaultKey) throw new Error('Vault is locked');\n\t\t\n\t\t// Store encrypted data in IndexedDB (simplified)\n\t\tconst db = await openDB();\n\t\tconst tx = db.transaction(collection, 'readwrite');\n\t\tawait tx.objectStore(collection).put({\n\t\t\tid: data.id || crypto.randomUUID(),\n\t\t\tdata: JSON.stringify(data),\n\t\t\ttimestamp: Date.now()\n\t\t});\n\t}\n\n\tasync function query(collection: string, options?: QueryOptions) {\n\t\tif (!vaultKey) throw new Error('Vault is locked');\n\t\t\n\t\t// Query from IndexedDB (simplified)\n\t\tconst db = await openDB();\n\t\tconst tx = db.transaction(collection, 'readonly');\n\t\tconst items = await tx.objectStore(collection).getAll();\n\t\t\n\t\treturn items.map(item => JSON.parse(item.data));\n\t}\n\n\tasync function openDB(): Promise<IDBDatabase> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open('volli_vault', 1);\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t\trequest.onsuccess = () => resolve(request.result);\n\t\t\t\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = (event.target as IDBOpenDBRequest).result;\n\t\t\t\t['messages', 'contacts', 'files'].forEach(collection => {\n\t\t\t\t\tif (!db.objectStoreNames.contains(collection)) {\n\t\t\t\t\t\tdb.createObjectStore(collection, { keyPath: 'id' });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t}\n\n\treturn {\n\t\tsubscribe,\n\t\tinitialize,\n\t\tunlock,\n\t\tlock,\n\t\tstore,\n\t\tquery\n\t};\n}\n\nexport const vault = createVaultStore();"],"names":["createVaultStore","subscribe","set","update","writable","vaultKey","initialize","state","get","auth","storedKey","error","unlock","passphrase","data","hashBuffer","lock","store","collection","openDB","query","options","item","resolve","reject","request","event","db","vault"],"mappings":"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"}