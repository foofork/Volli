{"version":3,"file":"messages.8ac05859.js","sources":["../../../../../../src/lib/stores/messages.ts"],"sourcesContent":["import { writable, derived } from 'svelte/store';\nimport { vault } from './vault';\n\n// Local type definitions\ninterface MessageContent {\n\ttype: 'text' | 'file' | 'image';\n\ttext?: string;\n\tfileId?: string;\n\tmetadata?: Record<string, any>;\n}\n\ninterface Message {\n\tid: string;\n\tconversationId: string;\n\tsenderId: string;\n\tcontent: MessageContent;\n\ttimestamp: Date;\n\tstatus: 'sending' | 'sent' | 'delivered' | 'read' | 'failed';\n\tversion: number;\n}\n\ninterface Conversation {\n\tid: string;\n\ttype: 'direct' | 'group';\n\tparticipants: string[];\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n\tlastMessage?: Message;\n\tmetadata: {\n\t\tname: string;\n\t\tavatar: string;\n\t\tdescription: string;\n\t};\n}\n\ninterface MessagesState {\n\tconversations: Map<string, Conversation>;\n\tmessages: Map<string, Message[]>;\n\tactiveConversationId: string | null;\n\tisLoading: boolean;\n\terror: string | null;\n}\n\nfunction createMessagesStore() {\n\tconst { subscribe, set, update } = writable<MessagesState>({\n\t\tconversations: new Map(),\n\t\tmessages: new Map(),\n\t\tactiveConversationId: null,\n\t\tisLoading: false,\n\t\terror: null\n\t});\n\n\tasync function loadConversations() {\n\t\tupdate(state => ({ ...state, isLoading: true, error: null }));\n\t\t\n\t\ttry {\n\t\t\tconst conversations = await vault.query('messages', {\n\t\t\t\ttype: 'conversation'\n\t\t\t});\n\t\t\t\n\t\t\tconst conversationsMap = new Map<string, Conversation>();\n\t\t\tconversations.forEach((conv: Conversation) => {\n\t\t\t\tconversationsMap.set(conv.id, conv);\n\t\t\t});\n\t\t\t\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tconversations: conversationsMap,\n\t\t\t\tisLoading: false\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to load conversations'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function loadMessages(conversationId: string) {\n\t\ttry {\n\t\t\tconst messages = await vault.query('messages', {\n\t\t\t\tconversationId,\n\t\t\t\ttype: 'message'\n\t\t\t});\n\t\t\t\n\t\t\tupdate(state => {\n\t\t\t\tconst newMessages = new Map(state.messages);\n\t\t\t\tnewMessages.set(conversationId, messages);\n\t\t\t\treturn { ...state, messages: newMessages };\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tupdate(state => ({\n\t\t\t\t...state,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to load messages'\n\t\t\t}));\n\t\t}\n\t}\n\n\tasync function createConversation(participants: string[], name?: string): Promise<string> {\n\t\tconst conversation: Conversation = {\n\t\t\tid: crypto.randomUUID(),\n\t\t\ttype: participants.length > 2 ? 'group' : 'direct',\n\t\t\tparticipants,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date(),\n\t\t\tmetadata: {\n\t\t\t\tname: name || `Chat with ${participants.join(', ')}`,\n\t\t\t\tavatar: '',\n\t\t\t\tdescription: ''\n\t\t\t}\n\t\t};\n\t\t\n\t\tawait vault.store('messages', { ...conversation, type: 'conversation' });\n\t\t\n\t\tupdate(state => {\n\t\t\tconst newConversations = new Map(state.conversations);\n\t\t\tnewConversations.set(conversation.id, conversation);\n\t\t\treturn { ...state, conversations: newConversations };\n\t\t});\n\t\t\n\t\treturn conversation.id;\n\t}\n\n\tasync function sendMessage(conversationId: string, content: MessageContent) {\n\t\tconst message: Message = {\n\t\t\tid: crypto.randomUUID(),\n\t\t\tconversationId,\n\t\t\tsenderId: 'current-user', // Get from auth store\n\t\t\tcontent,\n\t\t\ttimestamp: new Date(),\n\t\t\tstatus: 'sent',\n\t\t\tversion: 1\n\t\t};\n\t\t\n\t\tawait vault.store('messages', { ...message, type: 'message' });\n\t\t\n\t\tupdate(state => {\n\t\t\tconst newMessages = new Map(state.messages);\n\t\t\tconst conversationMessages = newMessages.get(conversationId) || [];\n\t\t\tnewMessages.set(conversationId, [...conversationMessages, message]);\n\t\t\t\n\t\t\t// Update conversation's last message\n\t\t\tconst newConversations = new Map(state.conversations);\n\t\t\tconst conversation = newConversations.get(conversationId);\n\t\t\tif (conversation) {\n\t\t\t\tconversation.lastMessage = message;\n\t\t\t\tconversation.updatedAt = new Date();\n\t\t\t\tnewConversations.set(conversationId, conversation);\n\t\t\t}\n\t\t\t\n\t\t\treturn { \n\t\t\t\t...state, \n\t\t\t\tmessages: newMessages,\n\t\t\t\tconversations: newConversations\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction setActiveConversation(conversationId: string | null) {\n\t\tupdate(state => ({ ...state, activeConversationId: conversationId }));\n\t\tif (conversationId) {\n\t\t\tloadMessages(conversationId);\n\t\t}\n\t}\n\n\treturn {\n\t\tsubscribe,\n\t\tloadConversations,\n\t\tloadMessages,\n\t\tcreateConversation,\n\t\tsendMessage,\n\t\tsetActiveConversation\n\t};\n}\n\nexport const messages = createMessagesStore();\n\nexport const activeConversation = derived(\n\tmessages,\n\t$messages => $messages.activeConversationId ? \n\t\t$messages.conversations.get($messages.activeConversationId) : null\n);\n\nexport const activeMessages = derived(\n\tmessages,\n\t$messages => $messages.activeConversationId ? \n\t\t$messages.messages.get($messages.activeConversationId) || [] : []\n);"],"names":["createMessagesStore","subscribe","set","update","writable","loadConversations","state","conversations","vault","conversationsMap","conv","error","loadMessages","conversationId","messages","newMessages","createConversation","participants","name","conversation","newConversations","sendMessage","content","message","conversationMessages","setActiveConversation","activeConversation","derived","$messages","activeMessages"],"mappings":"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"}